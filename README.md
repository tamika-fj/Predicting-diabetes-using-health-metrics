In this project I made a health website where users could input various health metrics and a model would predict their diabetes status. To create the model, I used data from a study of Indian women from 1990 from the National Institute of Diabetes and Digestive and Kidney Disease. The raw data was collected from https://www.kaggle.com/datasets/mathchi/diabetes-data-set and is in the resources folder of the repository (Project_4_Tamika_Josiah) called diabetes.csv. 

Before making the model the data was prepared in the Data cleaning pandas file. After reading about the raw data I found that 227 null values were inaccurate readings rather than true null values, thus I replaced them with median values rather than dropping the rows so I would have a more robust dataset. The pregnancy column was then dropped so that the model could be applied to both males and females. Having binary data can improve the strength of the model so I then created 3 additional columns for BMI, Blood Pressure and Glucose that put the readings into a category, I would also use this for additional functionality on the website. The cleaned csv file was exported to the resources folder as “cleaned_diabetes_df.csv” 
Next I created a logistic regression model using the data in the “Creating a model” pandas file. After converting the classifications in the BMI, BP and Glucose columns to encoded values I split the data into test and training. I then trained the model and tested it with a classification report. The model had an accuracy of 0.70 and precision of 0.76 and 0.64 for 0 and 1 (no diabetes and diabetes) respectively. To try and improve the accuracy of the model I then tried random forest, decision tress and k nearest neighbours with the same dataset, this was done in the “Creating a decision tree and random forest model” pandas file . A standard scaler was used to tune the model. Out of the three the random forest model was the most accurate with 0.7, the same accuracy as the logistic regression model and the precision of the 0 value was higher at 0.82, but there was a decrease in the accuracy of the 1 outcome and as this was a health model and we don’t want false negatives further tuning was done. A logistic regression (“creating a model without encoded values”.ipynb), k nearest neighbours, random forest and decision tree model (“creating a decision tree and random forest model without encoded values.ipynb) were then also made with an altered dataset. All the encoded values that had been calculated at data cleaning were dropped. This then lead to an increase in accuracy and precision, with the best model being the logistic regression model. The accuracy increased to 0.77% with an 80% precision score for 0 (no diabetes) and a 0.73 precision score for 1 (diabetes). This model was then exported as a joblib file to be used in the flask web application called diabetes_model.joblib. I also uploaded a model report text document outlining the model I chose and why.
To create the website I used a flask application called practice.py and HTML and CSS files. All HTML files were contained in the templates folder and my css file was contained in the styles folder within the static folder. I created a base HTML file to use as a template for all my other webpages, this contained the styling and links for the navigation bar as well as the scripts for bootstrap and jQuery. it also contains the style.css file which formats all the pages. Despite numerous attempts individual .css pages did not have any effect on the styling of they’re respective pages. As a result all of the styling was carried out using the style.css file and individual classes for specific elements, or as a style function on the HTML pages themselves. The website opened with the home_page.html which contained the welcome message and three large buttons that could take the user to the diabetes predictor, metrics tester and the information page. The diabetes predictor used the Predictor.HTML to create input boxes for the user to type in their BMI, age, glucose levels and diastolic blood pressure. The flask app then took in user inputs for the four features and combined them in a dataframe with median values for the other features to make a prediction of 1 or 0. This response was then converted to a written answer of diabetes risk or no diabetes risk which was displayed on the page.

Next there was the metrics.html page which created boxes for users to input there BMI, glucose and blood pressure values. The flask application then in took these three values and categorized them using conditional python code. The classification of each metric was then displayed on the page. The information button took the user to a page which described each metric used to create the model and some information about diabetes. To make this section the following websites were used. 
•	https://diabetesjournals.org/care/article/31/Supplement_2/S249/24832/Diastolic-Pressure-in-Type-2-DiabetesCan-target
•	https://www.verywellfit.com/calculate-body-fat-by-measuring-skinfolds-3120273
•	https://www.levelshealth.com/blog/what-are-normal-insulin-levels-and-why-dont-we-test-it-more
•	https://www.ncbi.nlm.nih.gov/books/NBK279331/#:~:text=The%20test%20can%20be%20done,determine%20the%20blood%20sugar%20level.
•	https://openventio.org/wp-content/uploads/Determinants-of-Gestational-Diabetes-Pedigree-Function-for-Pima-Indian-Females-IMOJ-6-121.pdf
•	https://www.diabetes.org.uk/guide-to-diabetes/complications
•	https://www.cdc.gov/diabetes/basics/diabetes.html
To created the bar graphs I used the “cleaned_diabetes_df.csv” in the Health Information Graphs Jupiter notebook file. The two graphs that I used were exported to the static folder as BMI_bar and BP_bar. In the navigation bar there is a get advice button. This take the user to the Nearest_Doc.html created the box for the user to input their Victorian postcode followed by vic to find three doctors close to them. Originally I attempted to perform the geoapify calls in a JavaScript and then a flask application where it would take in the postal code and convert it to longitude and latitude and give the nearest doctors. After troubleshooting I found that geoapify was never returning any data when the postcode was being input. To work around this I found the co-ordinates for all the postcodes in Victoria using a for loop jupyter notebook and exported this as the zip_codes.csv in the resources folder. I then found the three nearest doctors for each of these postcodes using a series of for loops to break up the API calls to approx. 300 at a time in the “Doctors_data.ipynb” and exported the dataframe as a .json file to the resources folder (doctors_data.json). This json file was then loaded into the flask application and using conditional code the flask application pulled up the 3 nearest doctors from the json file that matched the postcode the user input based on the individual number that had been given to each input. 

Lastly there was the BMI_con.html which could be accessed by the navigation bar which created the box for the user to input their height and weight which flask would then accept and perform a calculation (weight/ (height2)) to provide the user with their BMI. 
